/*
SPDX-License-Identifier: BSD-2-Clause License
Ported from: https://github.com/DarkoVeberic/LambertW/blob/master/FukushimaLambertW.cc

The original code (FukushimaLambertW.cc) refers to following publication and Fortran code:

- Toshio Fukushima, "Precise and fast computation of Lambert W-functions without
  transcendental function evaluations", J. Comp. Appl. Math. 244 (2013) 77-89.

I used Toshio Fukushima's routine because the code is easier to port. Darko Veberiƒç's code
may be faster.

Modification:
- Changed `LambertWm1(0)` to return `-Infinity` instead of `NaN`.
*/

function LambertWSeries(p) {
  const q = [
    -1,
    +1,
    -0.333333333333333333,
    +0.152777777777777778,
    -0.0796296296296296296,
    +0.0445023148148148148,
    -0.0259847148736037625,
    +0.0156356325323339212,
    -0.00961689202429943171,
    +0.00601454325295611786,
    -0.00381129803489199923,
    +0.00244087799114398267,
    -0.00157693034468678425,
    +0.00102626332050760715,
    -0.000672061631156136204,
    +0.000442473061814620910,
    -0.000292677224729627445,
    +0.000194387276054539318,
    -0.000129574266852748819,
    +0.0000866503580520812717,
    -0.0000581136075044138168
  ];
  const ap = Math.abs(p);
  if (ap < 0.01159) {
    return -1 + //
      p*(1 +    //
      p*(q[2] + //
      p*(q[3] + //
      p*(q[4] + //
      p*(q[5] + //
      p*q[6]    //
      )))));
  } else if (ap < 0.0766) {
    return -1 + //
      p*(1 +    //
      p*(q[2] + //
      p*(q[3] + //
      p*(q[4] + //
      p*(q[5] + //
      p*(q[6] + //
      p*(q[7] + //
      p*(q[8] + //
      p*(q[9] + //
      p*q[10]   //
      )))))))));
  } else {
    return -1 +  //
      p*(1 +     //
      p*(q[2] +  //
      p*(q[3] +  //
      p*(q[4] +  //
      p*(q[5] +  //
      p*(q[6] +  //
      p*(q[7] +  //
      p*(q[8] +  //
      p*(q[9] +  //
      p*(q[10] + //
      p*(q[11] + //
      p*(q[12] + //
      p*(q[13] + //
      p*(q[14] + //
      p*(q[15] + //
      p*(q[16] + //
      p*(q[17] + //
      p*(q[18] + //
      p*(q[19] + //
      p*q[20]    //
      )))))))))))))))))));
  }
}

function LambertW0ZeroSeries(z) {
  return z*(1 -                //
    z*(1 -                     //
    z*(1.5 -                   //
    z*(2.6666666666666666667 - //
    z*(5.2083333333333333333 - //
    z*(10.8 -                  //
    z*(23.343055555555555556 - //
    z*(52.012698412698412698 - //
    z*(118.62522321428571429 - //
    z*(275.57319223985890653 - //
    z*(649.78717234347442681 - //
    z*(1551.1605194805194805 - //
    z*(3741.4497029592385495 - //
    z*(9104.5002411580189358 - //
    z*(22324.308512706601434 - //
    z*(55103.621972903835338 - //
    z*136808.86090394293563    //
    ))))))))))))))));
}

function FinalResult(w, y) {
  const f0 = w - y;
  const f1 = 1 + y;
  const f00 = f0 * f0;
  const f11 = f1 * f1;
  const f0y = f0 * y;
  return w
    - 4 * f0 * (6 * f1 * (f11 + f0y) + f00 * y)
    / (f11 * (24 * f11 + 36 * f0y) + f00 * (6 * y * y + 8 * f1 * y + f0y));
}

export function LambertW0(z) {
  // // The table below comes from following code.
  //
  // let e = new Array(66).fill(0);
  // let g = new Array(65).fill(0);
  // let a = new Array(12).fill(0);
  // let b = new Array(12).fill(0);
  // if (!e[0]) {
  //   const e1 = 1 / Math.E;
  //   let ej = 1;
  //   e[0] = Math.E;
  //   e[1] = 1;
  //   g[0] = 0;
  //   for (let j = 1, jj = 2; jj < 66; ++jj) {
  //     ej *= Math.E;
  //     e[jj] = e[j] * e1;
  //     g[j] = j * ej;
  //     j = jj;
  //   }
  //   a[0] = Math.sqrt(e1);
  //   b[0] = 0.5;
  //   for (let j = 0, jj = 1; jj < 12; ++jj) {
  //     a[jj] = Math.sqrt(a[j]);
  //     b[jj] = b[j] * 0.5;
  //     j = jj;
  //   }
  // }

  const e = [
    2.718281828459045,       1.00000000000,           0.36787944117144233,
    0.1353352832366127,      0.04978706836786395,     0.018315638888734186,
    0.00673794699908547,     0.0024787521766663594,   0.0009118819655545166,
    0.00033546262790251196,  0.0001234098040866796,   0.00004539992976248487,
    0.000016701700790245666, 0.000006144212353328212, 0.0000022603294069810555,
    8.315287191035683e-7,    3.0590232050182594e-7,   1.1253517471925917e-7,
    4.139937718785169e-8,    1.5229979744712636e-8,   5.60279643753727e-9,
    2.061153622438559e-9,    7.582560427911912e-10,   2.7894680928689267e-10,
    1.0261879631701898e-10,  3.775134544279101e-11,   1.3887943864964032e-11,
    5.109089028063329e-12,   1.879528816539085e-12,   6.914400106940209e-13,
    2.5436656473769253e-13,  9.357622968840184e-14,   3.44247710846998e-14,
    1.2664165549094188e-14,  4.6588861451034025e-15,  1.713908431542015e-15,
    6.305116760146997e-16,   2.319522830243572e-16,   8.533047625744076e-17,
    3.139132792048033e-17,   1.15482241730158e-17,    4.248354255291594e-18,
    1.5628821893349907e-18,  5.749522264293568e-19,   2.1151310375910834e-19,
    7.781132241133807e-20,   2.862518580549398e-20,   1.0530617357553828e-20,
    3.873997628687193e-21,   1.4251640827409372e-21,  5.242885663363472e-22,
    1.9287498479639209e-22,  7.095474162284715e-23,   2.6102790696677092e-23,
    9.602680054508692e-24,   3.532628572200813e-24,   1.2995814250075053e-24,
    4.780892883885477e-25,   1.7587922024243146e-25,  6.470234925645471e-26,
    2.3802664086944047e-26,  8.756510762696536e-27,   3.221340285992522e-27,
    1.1850648642339833e-27,  4.35961000006309e-28,    1.603810890548641e-28
  ];
  const g = [
    0.0000000000,           2.718281828459045,      14.778112197861299,
    60.256610769563,        218.39260013257692,     742.0657955128829,
    2420.57276095641,       7676.432108999208,      23847.66389633382,
    72927.75534817843,      220264.65794806706,     658615.5588671757,
    1953057.4970280458,     5751374.096115963,      16836459.978306863,
    49035260.58708162,      142177768.32812583,     410634196.8107797,
    1181879444.4719481,     3391163718.3005548,     9703303908.195797,
    27695130424.147484,     78868082614.89493,      224130479263.72452,
    635738931116.2426,      1800122483434.6448,     5088969845149.802,
    14365302496248.545,     40495197800161.26,      114008694617177.08,
    320594237445733.44,     900514339622668.9,      2526814725845778.5,
    7083238132935220,       19837699245933436,      55510470830969990,
    155204335696146780,     433608267793695900,     1210525406770320600,
    3377142616535750700,    9415410673480784000,    26233583234732210000,
    73049547543860920000,   203297097133861540000,  565470405031808470000,
    1.5720421975868262e+21, 4.368214933477117e+21,  1.2132170565093289e+22,
    3.3680332378068553e+22, 9.345998205225967e+22,  2.5923527642935304e+23,
    7.187680320377372e+23,  1.9921241603726153e+24, 5.519292499505402e+24,
    1.5286067837683307e+25, 4.232131895828099e+25,  1.1713293177672749e+26,
    3.240860399621473e+26,  8.964125826422578e+26,  2.478714138236396e+27,
    6.852044338894086e+27,  1.8936217407781657e+28, 5.231781134619686e+28,
    1.4450833904658498e+29, 3.990495411719422e+29
  ];
  const a = [
    0.6065306597126334, 0.7788007830714049, 0.8824969025845955, 0.9394130628134758,
    0.9692332344763441, 0.9844964370054085, 0.9922179382602435, 0.9961013694701175,
    0.9980487811074755, 0.9990239141819757, 0.9995118379398894, 0.9997558891748972
  ];
  const b = [
    0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125,
    0.0009765625, 0.00048828125, 0.000244140625
  ];

  if (Math.abs(z) < 0.05) return LambertW0ZeroSeries(z);
  if (z < -0.35) {
    const p2 = 2 * (Math.E * z + 1);
    if (p2 > 0) return LambertWSeries(Math.sqrt(p2));
    if (p2 == 0) return -1;
    console.warn(`(lambertw0) Argument out of range. z=${z}`);
    return NaN;
  }

  // In the original code, `line1` is implemented as goto label.
  const line1 = (n, a, b) => {
    --n;
    let jmax = 8;
    if (z <= -0.36)
      jmax = 12;
    else if (z <= -0.3)
      jmax = 11;
    else if (n <= 0)
      jmax = 10;
    else if (n <= 1)
      jmax = 9;
    let y = z * e[n + 1];
    let w = n;
    for (let j = 0; j < jmax; ++j) {
      const wj = w + b[j];
      const yj = y * a[j];
      if (wj < yj) {
        w = wj;
        y = yj;
      }
    }
    return FinalResult(w, y);
  };

  let n;
  for (n = 0; n <= 2; ++n) {
    if (g[n] > z) return line1(n, a, b);
  }
  n = 2;
  for (let j = 1; j <= 5; ++j) {
    n *= 2;
    if (g[n] > z) {
      // This branch is `line2` goto label in the original code.
      let nh = n / 2;
      for (let j = 1; j <= 5; ++j) {
        nh /= 2;
        if (nh <= 0) break;
        if (g[n - nh] > z) n -= nh;
      }
      return line1(n, a, b);
    }
  }
  console.warn(`(lambertw0) Argument too large. z=${z}`);
  return NaN;
}

export function LambertWm1(z) {
  // // The table below comes from following code.
  //
  // let e = new Array(64).fill(0);
  // let g = new Array(64).fill(0);
  // let a = new Array(12).fill(0);
  // let b = new Array(12).fill(0);
  // if (!e[0]) {
  //   const e1 = 1 / Math.E;
  //   let ej = e1;
  //   e[0] = Math.E;
  //   g[0] = -e1;
  //   for (let j = 0, jj = 1; jj < 64; ++jj) {
  //     ej *= e1;
  //     e[jj] = e[j] * Math.E;
  //     g[jj] = -(jj + 1) * ej;
  //     j = jj;
  //   }
  //   a[0] = Math.sqrt(Math.E);
  //   b[0] = 0.5;
  //   for (let j = 0, jj = 1; jj < 12; ++jj) {
  //     a[jj] = Math.sqrt(a[j]);
  //     b[jj] = b[j] * 0.5;
  //     j = jj;
  //   }
  // }

  const e = [
    2.718281828459045,      7.3890560989306495,     20.085536923187664,
    54.59815003314423,      148.41315910257657,     403.428793492735,
    1096.6331584284583,     2980.9579870417274,     8103.0839275753815,
    22026.465794806707,     59874.14171519779,      162754.79141900383,
    442413.3920089202,      1202604.2841647759,     3269017.372472108,
    8886110.520507865,      24154952.753575277,     65659969.13733045,
    178482300.9631871,      485165195.4097898,      1318815734.4832134,
    3584912846.131588,      9744803446.248892,      26489122129.84344,
    72004899337.38579,      195729609428.83853,     532048240601.798,
    1446257064291.4734,     3931334297144.037,      10686474581524.447,
    29048849665247.383,     78962960182680.58,      214643579785915.75,
    583461742527454,        1586013452313428.2,     4311231547115188.5,
    11719142372802592,      31855931757113704,      86593400423993600,
    235385266837019600,     639843493530053900,     1739274941520498200,
    4727839468229338000,    12851600114359284000,   34934271057485025000,
    94961194206024290000,   258131288619006160000,  701673591209761600000,
    1.9073465724950953e+21, 5.18470552858706e+21,   1.4093490824269355e+22,
    3.831008000716568e+22,  1.0413759433029062e+23, 2.8307533032746866e+23,
    7.694785265141997e+23,  2.0916594960129907e+24, 5.685719999335917e+24,
    1.5455389355900996e+25, 4.201210403790502e+25,  1.142007389815681e+26,
    3.104297935701911e+26,  8.438356668741429e+26,  2.2937831594696028e+27,
    6.235149080811597e+27
  ];
  const g = [
    -0.36787944117144233,      -0.2706705664732254,      -0.14936120510359185,
    -0.07326255555493674,      -0.03368973499542735,     -0.014872513059998156,
    -0.006383173758881616,     -0.0026837010232200957,   -0.0011106882367801162,
    -0.00045399929762484866,   -0.00018371870869270232,  -0.00007373054823993854,
    -0.000029384282290753722,  -0.000011641402067449956, -0.000004588534807527389,
    -0.0000018005627955081467, -7.037894121934787e-7,    -2.741396354048274e-7,
    -1.0645313231320814e-7,    -4.122307244877118e-8,    -1.5923376898615014e-8,
    -6.1368298043116385e-9,    -2.3602323152914367e-9,   -9.060322906269842e-10,
    -3.471985966241008e-10,    -1.3283631472964657e-10,  -5.0747278046555293e-11,
    -1.9360320299432585e-11,   -7.376630377393084e-12,   -2.807286890652055e-12,
    -1.0671679036256938e-12,   -4.05253297571014e-13,    -1.5374324278841227e-13,
    -5.82728866724285e-14,     -2.206790866051449e-14,   -8.35028218887686e-15,
    -3.157227621525308e-15,    -1.1928704609782527e-15,  -4.503807427476162e-16,
    -1.6993417021166378e-16,   -6.407816976273462e-17,   -2.4147993510032983e-17,
    -9.095063461641659e-18,    -3.4236981860988753e-18,  -1.2881333612472291e-18,
    -4.844083984474761e-19,    -1.8207788854829806e-19,  -6.840787597156499e-20,
    -2.5690139750481013e-20,   -9.643749239819604e-21,   -3.618691822765205e-21,
    -1.3573451162272088e-21,   -5.089420428889607e-22,   -1.907619428988439e-22,
    -7.147697837541279e-23,    -2.677300014975867e-23,   -1.0025115553818592e-23,
    -3.7527362568743735e-24,   -1.4043571811296988e-24,  -5.253906457617922e-25,
    -1.9650175744554385e-25,   -7.347402158250696e-26,   -2.746554300039747e-26,
    -1.0264389699511303e-26
  ];
  const a = [
    1.6487212707001282, 1.2840254166877414, 1.1331484530668263, 1.0644944589178595,
    1.0317434074991028, 1.0157477085866857, 1.007843097206448, 1.0039138893383477,
    1.0019550335910028, 1.0009770394924165, 1.0004884004786945, 1.0002441704297478
  ];
  const b = [
    0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125,
    0.0009765625, 0.00048828125, 0.000244140625
  ];

  if (z == 0) return -Infinity;
  if (z > 0) {
    console.warn(`(lambertwm1) Argument out of range. z=${z}`);
    return NaN;
  }
  if (z < -0.35) {
    const p2 = 2 * (Math.E * z + 1);
    if (p2 > 0) return LambertWSeries(-Math.sqrt(p2));
    if (p2 == 0) return -1;
    console.warn(`(lambertwm1) Argument out of range. z=${z}`);
    return NaN;
  }

  const line1 = (n, a, b) => {
    --n;
    let jmax = 11;
    if (n >= 8)
      jmax = 8;
    else if (n >= 3)
      jmax = 9;
    else if (n >= 2)
      jmax = 10;
    let w = -n;
    let y = z * e[n - 1];
    for (let j = 0; j < jmax; ++j) {
      const wj = w - b[j];
      const yj = y * a[j];
      if (wj < yj) {
        w = wj;
        y = yj;
      }
    }
    return FinalResult(w, y);
  };

  let n = 2;
  if (g[n - 1] > z) return line1(n, a, b);
  for (let j = 1; j <= 5; ++j) {
    n *= 2;
    if (g[n - 1] > z) {
      let nh = n / 2;
      for (let j = 1; j <= 5; ++j) {
        nh /= 2;
        if (nh <= 0) break;
        if (g[n - nh - 1] > z) n -= nh;
      }
      return line1(n, a, b);
    }
  }
  console.warn(`(lambertwm1) Argument too small. z=${z}`);
  return NaN;
}

export function LambertW(x, branch) {
  switch (branch) {
    case -1:
      return LambertWm1(x);
    case 0:
      return LambertW0(x);
    default:
      return NaN;
  }
}
